#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_printf.h"
#include "xuartps.h"

//declaring an array which contains header (15 bytes) and pixel informations of an image 128x128
unsigned char image_array[128*128*3+15];   



int main()
{
    init_platform();
    XUartPs Uart_1_PS;
    u16 DeviceId_1= XPAR_PS7_UART_1_DEVICE_ID;
    int Status_1;
    XUartPs_Config *Config_1;
    Config_1 = XUartPs_LookupConfig(DeviceId_1);
    if (NULL == Config_1) {
      return XST_FAILURE;
    }
    Status_1 = XUartPs_CfgInitialize(&Uart_1_PS, Config_1, Config_1->BaseAddress); //initializing UART
    if (Status_1 != XST_SUCCESS) {
      return XST_FAILURE;
    }
    u32 BaudRate = (u32)115200;
    Status_1 = XUartPs_SetBaudRate(&Uart_1_PS, BaudRate); //setting BaudRate = 115200
    if (Status_1 != (s32)XST_SUCCESS) {
      return XST_FAILURE;
    }
    // Min (0) and max (255) are the min and max values for each pixel (color information in grayscale).
    // In this case, min is initialized as 255 and max as 0, because we use them to find the min and max
    // pixel value in the prototype image by comparing all pixel values.
    int min = 255;
    int max = 0;
    receive_image(&min, &max);     //stores bytes in image_array[] and determines min and max values
    negative();                    //inverts the color of each pixel
    scale(min, max);               //stretches the image histogram 

    cleanup_platform();
    return 0;
}


// receive_image is the function which determines min and max pixel values in the received image.
void receive_image(int* min_addr, int* max_addr){

	unsigned char my_pixel;
	for (int i=0; i<3*128*128+15; i++){
		my_pixel=XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);    //receiving bytes in input from UART
		if (my_pixel < *min_addr && i > 14) *min_addr = my_pixel; //calculating min color value
		if (my_pixel > *max_addr && i > 14) *max_addr = my_pixel; //calculating max color value
	    image_array[i]=my_pixel;   //storing bytes
	}
}

// negative is the function which inverts the value of color information for each pixel by subtracting
// the current value from 255
void negative(){

	for (int i=0; i<3*128*128+15; i++){
		if (i > 14) {                                                //if the i-th byte is a pixel->negate and send to UART port
			unsigned char negated_pixel = 255-image_array[i];
			XUartPs_SendByte(XPAR_PS7_UART_1_BASEADDR, negated_pixel);
		} else {                                                     //if the i-th byte is an header byte->only send to UART port
			unsigned char header = image_array[i];
			XUartPs_SendByte(XPAR_PS7_UART_1_BASEADDR, header);
		}
	 }
}

// scale is the function which scales pixels values by stretching them between 0 and 255.
void scale(int min, int max){

	int scale = 255 / (max - min);              //scaling factor
	for (int i=0; i<3*128*128+15; i++){
		if (i > 14) {                                         //if the i-th byte is a pixel->scale and send to UART port
			unsigned char scaled_pixel = (image_array[i] - min) * scale;
			XUartPs_SendByte(XPAR_PS7_UART_1_BASEADDR, scaled_pixel);
		} else {                                              //if the i-th byte is an header byte->only send to UART port
			unsigned char header = image_array[i];
			XUartPs_SendByte(XPAR_PS7_UART_1_BASEADDR, header);
			}
	 }
}





//int start, stop;
// Xil_DCacheDisable();
//
// Xil_ICacheDisable();
// Xil_L2CacheDisable();
// start=Xil_In32(XPAR_GLOBAL_TMR_BASEADDR);
// for (int i=0;i<3*32*32;i++)
// 	image[i]=255-image[i];
// stop=Xil_In32(XPAR_GLOBAL_TMR_BASEADDR);
// xil_printf("Duration=%d \r\n", stop-start);
