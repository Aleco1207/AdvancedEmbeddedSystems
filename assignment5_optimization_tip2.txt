#include <stdio.h>
#include <stdlib.h>
#include "platform.h"
#include "xil_printf.h"
#include "xuartps.h"
#include "weights.h"
#include "custom_weights.h"
#include "custom_weights_q17.h"
#include "test_images.h"
#include <xtime_l.h>
#include <time.h>

#include <math.h>

#define n_bias0 64
#define n_weights0 50176
#define n_bias1 32
#define n_weights1 2048
#define n_bias2 10
#define n_weights2 320
#define n_custom_weights 640

typedef signed char DATA8;     //in this optimization we use Q1.7 format


//for custom network topology
DATA8 custom_gemm0_bias[n_bias0] = {gemm0_bias};               //size 64
DATA8 custom_gemm0_weights[n_weights0] = {gemm0_weights} ;     //size 784*64=50176
DATA8 custom_gemm1_bias[n_bias2] = {gemm1_bias};               //size 10
DATA8 custom_gemm1_weights[n_custom_weights] = {gemm1_weights};      //size 64*10=640

#define FIXED2FLOAT(a, qf) (((float) (a)) / (1<<qf))
#define FLOAT2FIXED(a, qf) ((short int) round((a) * (1<<qf)))

#define _MAX_ 127
#define _MIN_ -128

// DNN functions to compose your network

void FC_forward(DATA8* input, DATA8* output, int in_s, int out_s, DATA8* weights, DATA8* bias, int qf) ;
static inline int32_t saturate(int32_t mac);
static inline void relu_forward(DATA8* input, DATA8* output, int size);
int resultsProcessing(DATA8* results, int size);
void receive_image();

DATA8 image_array[28*28];   //defining the array that will contain bytes received from UART

u32 t_start, t_stop, t_end, receiving_time, classifying_time, total_time;


int main(){
  init_platform();

  //UART setup
  XUartPs Uart_1_PS;
  u16 DeviceId_1= XPAR_PS7_UART_1_DEVICE_ID;
  int Status_1;
  XUartPs_Config *Config_1;
  Config_1 = XUartPs_LookupConfig(DeviceId_1);
  if (NULL == Config_1) {
    return XST_FAILURE;
  }
  /*the default configuration is stored in Config and it can be used to initialize the controller */
  Status_1 = XUartPs_CfgInitialize(&Uart_1_PS, Config_1, Config_1->BaseAddress);
  if (Status_1 != XST_SUCCESS) {
    return XST_FAILURE;
  }
  // Set the BAUD rate
  u32 BaudRate = (u32)115200;
  Status_1 = XUartPs_SetBaudRate(&Uart_1_PS, BaudRate);
  if (Status_1 != (s32)XST_SUCCESS) {
    return XST_FAILURE;
  }
  //END UART SETUP
  xil_printf ("Started\n");

  //-----CUSTOM NETWORK TOPOLOGY with tip1 optimization-------
  //matriculation number 160 ----> group 0

   // declare arrays for inputs and for exchanging tensors between layers
    DATA8 output_gemm0[64];
    DATA8  input_gemm1[64];
    DATA8 output_gemm1[10];

    while (1){

    	  //Timer start
    	  t_start = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);

    	  receive_image(); //reading compressed image from UART

    	  t_stop = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);
    	  receiving_time = t_stop-t_start;   //measuring clock cycles needed for receiving image

    	  FC_forward(image_array, output_gemm0, 784, 64, custom_gemm0_weights, custom_gemm0_bias, 7);  //layer0
    	  relu_forward(output_gemm0, input_gemm1, 64);
      	  FC_forward(input_gemm1, output_gemm1, 64, 10, custom_gemm1_weights, custom_gemm1_bias, 7);   //layer1
      	  resultsProcessing(output_gemm1, 10);

          //Timer stop
    	  t_end = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);
    	  classifying_time = t_end - t_stop; //measuring clock cycles needed for classifying image
    	  total_time = t_end-t_start; //measuring clock cycles needed for the whole processing
    	  xil_printf("Receiving Duration: %u\r\n", receiving_time);
    	  xil_printf("Classifying Duration: %u\r\n", classifying_time);
    	  xil_printf("Total Duration: %u\r\n", total_time);

      }


    cleanup_platform();
    return 0;
}


void FC_forward(DATA8* input, DATA8* output, int in_s, int out_s, DATA8* weights, DATA8* bias, int qf) {
	// NOTE return W * x
	int hkern = 0;
	int wkern = 0;
	int32_t mac = 0;
	DATA8 current = 0;

	/* foreach row in kernel */
//	#pragma omp parallel for private (hkern, wkern, mac, current)
	for (hkern = 0; hkern < out_s; hkern++) {
		mac = ((int32_t)bias[hkern]) << qf;
		for (wkern = 0; wkern < in_s; wkern++) {
			current = input[wkern];
			mac += current * weights[hkern*in_s + wkern];
		}
		mac = mac >> qf;
		output[hkern]=(DATA8)saturate(mac);
	}
}

static inline int32_t saturate(int32_t mac)
{

	if(mac > _MAX_) {
		printf("[WARNING] Saturation POS: %d > %d\r\n", mac, _MAX_);  //positive saturation
		return _MAX_;
	}

	if(mac < _MIN_){
		printf("[WARNING] Saturation NEG: %d < %d\r\n", mac, _MIN_);  //negative saturation
		return _MIN_;
	}

	//printf("mac: %lld -> %llx _MAX_: %lld  _MIN_: %lld  res: %lld\n", mac, mac, _MAX_, _MIN_, mac);
    return mac;

}

static inline void relu_forward(DATA8* input, DATA8* output, int size) {
	int i = 0;
	for(i = 0; i < size; i++) {
		DATA8 v = input[i];
		v = v > 0 ? v : 0;
		output[i] = v;
	}
}

#define SIZEWA 10
int resultsProcessing(DATA8* results, int size){
//What do you want to do with the results of the CNN? Here is the place where you should put the classifier or the detection (see YOLO detection for example)
//The simplest classifier is a maximum search for the results which returns the index value of the maximum

 char *labels[10]={"digit 0", "digit 1", "digit 2", "digit 3", "digit 4", "digit 5", "digit 6", "digit 7", "digit 8", "digit 9"};

// TODO: check the size parameter
  int size_wa = SIZEWA;
  float  r[SIZEWA];
  int  c[SIZEWA];
  float results_float[SIZEWA];
  float sum=0.0;
  DATA8 max=0;
  int max_i;
  for (int i =0;i<size_wa;i++){
      results_float[i] = FIXED2FLOAT(results[i],7);   //coherent to Q1.7 format
    int n;
    if (results[i]>0)
      n=results[i];
    else
      n=-results[i];
    if (n>max){
      max=n;
      max_i=i;
    }
  }
  for (int i =0;i<size_wa;i++)
    sum+=exp(results_float[i]);

  for (int i =0;i<size_wa;i++){
    r[i]=exp(results_float[i]) / sum;
    c[i]=i;
  }
  for (int i =0;i<size_wa;i++){
    for (int j =i;j<size_wa;j++){
      if (r[j]>r[i]){
        float t= r[j];
        r[j]=r[i];
        r[i]=t;
        int tc= c[j];
        c[j]=c[i];
        c[i]=tc;
      }
    }
  }
  int top0=0;
  float topval=results_float[0];
  for (int i =1;i<size_wa;i++){
    if (results_float[i]>topval){
      top0=i;
      topval=results_float[i];
    }
  }
  //xil_printf("\n\n");
  for (int i =0;i<5;i++){
//	  xil_printf("            TOP %d: [%d] %s   \n",i, c[i], labels[c[i]]);
  }
  xil_printf("max= %x \n",top0);
  return top0;
}

//for optimizing, we only receive byte from UART and insert them in image_array
//without reformatting in 16 bit pixels

void receive_image(){
	xil_printf("Waiting for an image ...\r\n");
	for (int i=0; i<28*28; i++){

		uint8_t raw_pixel = XUartPs_RecvByte(XPAR_PS7_UART_1_BASEADDR);   //receiving single bytes from UART
		image_array[i] = (DATA8)(raw_pixel >> 1);
	}
	xil_printf("Image successfully received!\r\n");
}

